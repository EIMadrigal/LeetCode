https://leetcode.com/problems/balanced-binary-tree/

My Solution:

Thought：
	按照平衡二叉树的定义，求出左右子树的高度，判断高度差是否大于1.
	求出当前结点左右子树的深度需要O(n)，要遍历每个结点，所以总复杂度O(n^2).
		
Code：
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
private:
	int depth(TreeNode* p)
	{
		return !p ? 0 : max(depth(p->left), depth(p->right)) + 1;
	}

public:
	bool isBalanced(TreeNode* root)
	{
		if (!root)
			return true;

		int height1 = depth(root->left);
		int height2 = depth(root->right);

		if (abs(height1 - height2) > 1)
			return false;
		else
			return isBalanced(root->left) && isBalanced(root->right);
	}
};

Performance:
	Runtime:20ms, beats 70.40%
	Memory:17.4MB, beats 42.14%
		
Superior Solution:

Thought：
	递归：根结点询问左子树和右子树是否平衡以及高度，
	到叶子结点，叶子的两个NULL子结点平衡且高度为-1，
	所以叶子可以判断自己的这棵子树是平衡的，并且叶子的结点高度是-1+1;
	将高度向上回溯，每个结点最多访问一次，复杂度O(n)。
	这个视频很清晰，不过我还是不太明白：
	https://www.youtube.com/watch?v=LU4fGD-fgJQ
	
		
Code：
class Solution {
private:
    //返回当前结点的高度
	int dfs(TreeNode* p)
	{
		if (!p)  
			return 0;

		int lheigh = dfs(p->left);
		if (lheigh == -1)
			return -1;

		int rheigh = dfs(p->right);
		if (rheigh == -1)
			return -1;

		int diff = lheigh - rheigh;
		
		if (abs(diff) > 1)
			return -1;
		
		return max(lheigh, rheigh) + 1;
	}

public:
	bool isBalanced(TreeNode* root)
	{
		if (!root)
			return true;

		return dfs(root) != -1;
	}
};

Performance:
	Runtime:16ms, beats 99.41%
	Memory:17.3MB, beats 56.92%
