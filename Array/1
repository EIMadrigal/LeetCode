https://leetcode.com/problems/two-sum/

My Solution:

Thought：
	暴力：两个指针分别指向两个数，判断其和是否等于target。
		
Code：
int* twoSum(int* nums, int numsSize, int target)
{
    int* p = (int *)malloc(numsSize*sizeof(int));
	for (int i = 0; i < numsSize; i++)
		for (int j = i + 1; j < numsSize; j++)
		{
			if (target == nums[i] + nums[j])
			{
				*p = i;
				*(p + 1) = j;
				break;
				break;
			}
		}
	return p;    
}

Performance:
	Runtime:76ms, beats 63.99%
	Memory:7.6MB, beats 82.22%
		
Superior Solution:

Thought：
	散列：unordered_map不会自动排序，可在常数时间复杂度内查找元素。
		
Code：
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> HashTable;
		vector<int> ans;
		int len = nums.size();

		for (int i = 0; i < len; i++)
		{
			int numsToFind = target - nums[i];
			if (HashTable.find(numsToFind) != HashTable.end())
			{
				ans.push_back(HashTable[numsToFind]);
				ans.push_back(i);
				break;
			}
            HashTable[nums[i]] = i;  //没找到，将当前数放入map，避免use the same element twice.
		}
		return ans;
    }
};

Performance:
	Runtime:12ms, beats 94.22%
	Memory:10.3MB, beats 42.79%
