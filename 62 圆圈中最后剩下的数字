暴力：链表模拟, 每次找到要删除的数O(m) 共删除n - 1次，O(nm)
class Solution {
public:
    int lastRemaining(int n, int m) {
        list<int> l;
        for (int i = 0; i < n; ++i) {
            l.push_back(i);
        }
        int cur = 0;
        while (n > 1) {
            cur = (cur + m - 1) % (l.size());
            auto it = l.begin();
            std::advance(it, cur);
            l.erase(it);
            n--;
        }
        return *l.begin();
    }
};


找规律从最后一轮反推初始时存活人的index：(当前index + m) % 上轮存活数字个数，将上一轮杀死的人补到最后，右移m并取模
class Solution {
public:
    int lastRemaining(int n, int m) {
        int ans = 0;
        for (int i = 2; i <= n; ++i) {
            ans = (ans + m) % i;
        }
        return ans;
    }
};
