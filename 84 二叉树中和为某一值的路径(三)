# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param sum int整型 
# @return int整型
#

# 遍历每个结点n，以n作为根结点寻找路径
# 最好情况：T(n) = 2T(n/2) + n -> O(nlgn)
# 最坏情况：T(n) = T(n - 1) + n -> O(n^2)
class Solution:
    def FindPath(self, root: TreeNode, sum: int) -> int:
        
        def path_cnt(root, sum):
            if not root:
                return 0
            if root.val == sum:
                return 1 + path_cnt(root.left, 0) + path_cnt(root.right, 0)
            else:
                return path_cnt(root.left, sum - root.val) + path_cnt(root.right, sum - root.val)
        
        if not root:
            return 0
        return self.FindPath(root.left, sum) + self.FindPath(root.right, sum) + path_cnt(root, sum)


# 暴力做法问题在于重复计算，对于根结点需要计算下面结点的和，对其孩子又要重新计算下面结点的和
# 因此对每个结点如果能存储其到根的和（前缀和），这样就无需重复计算相同路径的和了，结点间的路径和 = 两个结点的前缀和之差
# 因此hashmap: 前缀和 -> 父结点到根结点出现该前缀和的路径数目
# 1 -> 0 -> 2 sum = 2 举例

class Solution:
    def FindPath(self, root: TreeNode, sum: int) -> int:
        # hashmap存储的是前缀和 -> 父结点到根结点出现该前缀和的路径数目
        # 因此如果从根结点开始的某条路径和为sum，这样初始化To consider path starting from root.
        cache = {0: 1}
        ans = 0
        
        def dfs(root, sum, cursum):
            nonlocal ans
            if not root:
                return
            cursum += root.val
            ans += cache.get(cursum - sum, 0)
            cache[cursum] = cache.get(cursum, 0) + 1
            
            dfs(root.left, sum, cursum)
            dfs(root.right, sum, cursum)
            cache[cursum] -= 1
            
        dfs(root, sum, 0)
        return ans

