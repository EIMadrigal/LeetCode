https://leetcode.com/problems/remove-nth-node-from-end-of-list/
My Solution:

Thought：
	只扫描一遍，很简单的快慢指针，WA了四次，qwq~
	
Code：
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) 
    {
        ListNode* second = head;
		ListNode* first = head;
		while (n--)
		{
			first = first->next;
		}

		//删除第一个结点特殊处理
		if (!first)
			return head->next;

		while (first->next)
		{
			first = first->next;
			second = second->next;
		}

        //指向first会出错
		second->next = second->next->next;
		return head;
    }
};
		
Superior Solution:

Thought：
	讨论区的代码总是很简洁。。。
	当p1和p2相遇时，返回其中一个；
	否则，假设p1先等于null，那么让p1重新指向headB；p2先等于null，让p2重新指向headA；
	这样在相遇点之前p1走了：lenA+lenB-public，p2走了：lenB+lenA-public。
	也就是说，如果有交叉点，那么p1和p2必然相遇。
		
Code：
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
    {
        	ListNode* p1 = headA, *p2 = headB;

		if (!p1 || !p2)
			return NULL;

		while (p1 && p2 && p1 != p2)
		{
			p1 = p1->next;
			p2 = p2->next;

			if (p1 == p2)
				return p1;

			if (p1 == NULL)
				p1 = headB;
			if (p2 == NULL)
				p2 = headA;
		}

		return p1;
    }
};

Performance:
	Runtime:60ms, beats 33.44%
	Memory:16.6MB, beats 89.57%
