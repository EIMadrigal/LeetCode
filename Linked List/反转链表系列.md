## 206 反转整个链表
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 开始 cur -> head, prev -> 链表末尾结点的下一个位置(None)
        # 结束 prev -> head, cur -> 链表末尾结点的下一个位置(None)
        cur, prev = head, None
        while cur:
            tmp = cur.next  # save the next node in order to change ptr
            cur.next = prev
            prev = cur
            cur = tmp
        return prev


class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        new_head = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return new_head
```

## 92 区间反转
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        last_unchanged = dummy = ListNode(next=head)
        
        for _ in range(left - 1):
            last_unchanged = last_unchanged.next
        
        cur = last_unchanged.next
        prev = None
        for _ in range(right - left + 1):
            tmp = cur.next
            cur.next = prev
            prev = cur
            cur = tmp
        last_unchanged.next.next = cur
        last_unchanged.next = prev
        return dummy.next
```

## 25 k个一组反转
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        dummy = pre_next_group = ListNode(next=head)
        left = right = dummy.next
        
        while True:
            cnt = 0
            while right and cnt < k:
                right = right.next
                cnt += 1
            
            if cnt == k:
                prev, cur = right, left
                # 标准的链表反转操作
                for _ in range(k):
                    tmp = cur.next
                    cur.next = prev
                    prev = cur
                    cur = tmp
                pre_next_group.next = prev
                pre_next_group = left
                left = right
            else:
                return dummy.next
```
