class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if len(nums) < 2:
            return False
        s = sum(nums)
        if s % 2 != 0 or max(nums) > s // 2:
            return False
        target = s // 2
        
        # dp[i][j]表示从前i个数中选若干个其和能否恰好等于j
        # dp[i][j]取决于选或不选nums[i]的结果: dp[i - 1][j - nums[i]]/dp[i][j]
        dp = [[False for _ in range(target + 1)] for _ in range(len(nums))]
        dp[0][nums[0]] = True
        
        for i in range(1, len(nums)):
            for j in range(1, target + 1):
                if nums[i] > j:
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]
        return dp[-1][-1]
		
		
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        s = sum(nums)
        if len(nums) < 2 or s % 2 == 1 or max(nums) > s // 2:
            return False
        
        target = s // 2
        dp = [False] * (1 + target)
        dp[nums[0]] = True
        
        for i in range(1, len(nums)):
            for j in range(target, 0, -1):
                if nums[i] > j:
                    dp[j] = dp[j]
                else:
                    dp[j] = dp[j] or dp[j - nums[i]]
        return dp[-1]
		
