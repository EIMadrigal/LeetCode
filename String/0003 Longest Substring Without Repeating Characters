Brute Force: Time: O(n^3), Space: O(n)
class Solution {
private:
    bool allUnique(string substring) {
        set<char> uniqueString;
        int size = substring.size();
        
        for(int i = 0;i < size;i++) {
            if(uniqueString.find(substring[i]) != uniqueString.end()) {
                return false;
            }
            else {
                uniqueString.insert(substring[i]);
            }
        }
        return true;
    }
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int ans = 0;
        
        for(int i = 0;i < n;i++) {
            for(int j = i;j < n;j++) {
                string substring = s.substr(i,j - i + 1);
                if(allUnique(substring) && j - i + 1 > ans) {
                    ans = j - i + 1;
                }
            }
        }
        return ans;
    }
};


Sliding Window: at most O(2n), Space: O(n)
最坏情况："acbbb"每个元素均要被i和j访问一次，每次要么i+1要么j+1，最终ij均等于len(s)才能终止，O(2n)
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int ans = 0;
        set<char> myset;
        
        for(int i = 0, j = 0;i < n && j < n;) {
            // try to extend the range [i,j]
            if(myset.find(s[j]) == myset.end()) {
                ans = max(ans, j - i + 1);
                myset.insert(s[j++]);
            }
            else {
                myset.erase(s[i++]);
            }
        }
        return ans;
    }
};

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        ans = i = j = 0
        seen = set()
        while i < len(s) and j < len(s):
            if s[j] not in seen:
                ans = max(ans, j - i + 1)
                seen.add(s[j])
                j += 1
            else:
                seen.remove(s[i])
                i += 1
        return ans
        

Sliding Window Optimized: at most O(n), Space: O(n)
为避免无效循环，如果s[j]与[i,j]中的j'重复，那么没有必要逐一增加i，直接将i增加为j'+1
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int ans = 0;
        unordered_map<char, int> mymap;
        
        for(int i = 0, j = 0;i < n && j < n;j++) {
            // try to extend the range [i,j]
            if(mymap.find(s[j]) != mymap.end()) {
                i = max(mymap[s[j]] + 1, i);
            }
            mymap[s[j]] = j;
            ans = max(ans, j - i + 1);
        }
        return ans;
    }
};

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        ans = i = 0
        seen = {}
        for j in range(len(s)):
            if s[j] in seen:
                i = max(seen[s[j]] + 1, i)  # case: tmmzuxt
            ans = max(ans, j - i + 1)
            seen[s[j]] = j
        return ans
        
